import datetime
import cv2
import tempfile
import json

from flask import render_template


def add_bounding_box(anno, frames):
    frame_num = anno.properties["frame"]
    box_id = anno.properties["id"]
    boxType = anno.properties["boxType"]
    coordinates = anno.properties["coordinates"]
    x = coordinates[0][0]
    y = coordinates[0][1]
    w = coordinates[3][0] - x
    h = coordinates[3][1] - y
    box = [box_id, boxType, [x, y, w, h]]
    if frame_num in frames.keys():
        frames[frame_num]["boxes"].append(box)
        frames[frame_num]["bb_ids"].append(box_id)
    else:
        frames[frame_num] = {"boxes": [box], "text": [], "bb_ids": [box_id], "timestamp": None, "secs": None, "repeat": False}
    return frames


def align_annotations(frames_list, alignments, text_docs, fps):
    """Link alignments with frames"""
    prev_frame = None
    for frame_num, frame in frames_list:
        if fps:
            secs = int(frame_num/fps)
            frame["timestamp"] = str(datetime.timedelta(seconds=secs))
            frame["secs"] = secs
        for box_id in frame["bb_ids"]:
            text_id = alignments[box_id]
            frame["text"].append(text_docs[text_id])
        if is_duplicate_ocr_frame(frame, prev_frame):
            frame["repeat"] = True
        prev_frame = frame
    return frames_list


def paginate(frames_list):
    """Generate pages from a list of frames"""
    pages = [[]]
    n_frames_on_page = 0
    for frame_num, frame in frames_list:
        if n_frames_on_page >= 4 and not frame["repeat"]:
            pages.append([])
            n_frames_on_page = 0

        pages[-1].append((frame_num, frame))

        if not frame["repeat"]:
            n_frames_on_page += 1

    return pages

def render_ocr(vid_path, frames_pages, page_number):
    """Iterate through frames and display the contents/alignments."""
    # Path for storing temporary images generated by cv2
    cv2_vid = cv2.VideoCapture(vid_path)
    for frame_num, frame in frames_pages[page_number]:
        cv2_vid.set(1, frame_num)
        _, frame_cap = cv2_vid.read()
        with tempfile.NamedTemporaryFile(
            prefix="/app/static/tmp/", suffix=".jpg", delete=False) as tf:
            print(tf.name)
            cv2.imwrite(tf.name, frame_cap)
            # "id" is just the name of the temp image file
            frame["id"] = tf.name[12:]            

    return render_template('ocr.html', 
                           vid_path=vid_path, 
                           frames_pages=frames_pages, 
                           page_number=page_number)


def is_duplicate_ocr_frame(frame, prev_frame):
    if prev_frame:
        # Check Boundingbox distances
        rounded_prev = round_boxes(prev_frame["boxes"])
        for box in round_boxes(frame["boxes"]):
            if box in rounded_prev and frame["secs"]-prev_frame["secs"] < 5:
                return True
    return False

def round_boxes(boxes):
    # To account for jittery bounding boxes in OCR annotations
    rounded_boxes = []
    for box in boxes:
        rounded_box = []
        for coord in box[2]:
            rounded_box.append(round(coord/10)*10)
        rounded_boxes.append(rounded_box)
    return rounded_boxes

def get_ocr_views(mmif):
    """Return OCR views, which have TextDocument, BoundingBox, and Alignment annotations"""
    views = []
    needed_types = ["TextDocument", "BoundingBox", "Alignment"]
    for view in mmif.views:
        annotation_types = [str(url).split("/")[-1] for url in view.metadata.contains.keys()]
        if needed_types == annotation_types:
            views.append(view)
    return views
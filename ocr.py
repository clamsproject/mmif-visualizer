import datetime
import cv2
import tempfile
import json
import re
import html

from flask import render_template, session
# from utils import app


class OCRFrame():
    """Class representing an (aligned or otherwise) set of OCR annotations for a single frame"""

    def __init__(self, anno, fps):
        self.text = []
        self.fps = fps
        self.boxes = []
        self.anno_ids = []
        self.timestamp = None
        self.secs = None
        self.repeat = False
        self.frame_num = None
        self.range = None
        self.timestamp_range = None
        self.sec_range = None

        self.update(anno)

    def update(self, anno):
        if anno.at_type.shortname == "BoundingBox":
            self.add_bounding_box(anno)

        elif anno.at_type.shortname == "TimeFrame":
            self.add_timeframe(anno)

        elif anno.at_type.shortname == "TextDocument":
            t = anno.properties.get("text_value") or anno.properties.get("text").value
            if t:
                self.text.append(re.sub(r'([\\\/\|\"\'])', r'\1 ', t))

    def add_bounding_box(self, anno):
        self.frame_num = anno.properties.get(
            "frame") or anno.properties.get("timePoint")
        box_id = anno.properties["id"]
        boxType = anno.properties["boxType"]
        coordinates = anno.properties["coordinates"]
        x = coordinates[0][0]
        y = coordinates[0][1]
        w = coordinates[3][0] - x
        h = coordinates[3][1] - y
        box = [box_id, boxType, [x, y, w, h]]
        self.boxes.append(box)
        self.anno_ids.append(box_id)
        if self.fps:
            secs = int(self.frame_num/self.fps)
            self.timestamp = str(datetime.timedelta(seconds=secs))
            self.secs = secs

    def add_timeframe(self, anno):
        start, end = anno.properties.get('start'), anno.properties.get('end')
        self.range = (start, end)
        if self.fps:
            start_secs, end_secs = int(start/self.fps), int(end/self.fps)
            self.timestamp_range = (str(datetime.timedelta(seconds=start_secs)), str(datetime.timedelta(seconds=end_secs)))
            self.sec_range = (start_secs, end_secs)

        # self.range = f"{anno.properties.get('start')}-{anno.properties.get('end')}"


def get_ocr_frames(view, fps):
    frames = {}
    full_alignment_type = [
        at_type for at_type in view.metadata.contains if at_type.shortname == "Alignment"]
    # If view contains alignments
    if full_alignment_type:
        for alignment in view.get_annotations(full_alignment_type[0]):
            source = view.get_annotation_by_id(alignment.properties["source"])
            target = view.get_annotation_by_id(alignment.properties["target"])
            frame = OCRFrame(source, fps)
            i = frame.frame_num or frame.range
            if i in frames.keys():
                frames[i].update(source)
                frames[i].update(target)
            else:
                frame.update(target)
                frames[i] = frame
    else:
        for annotation in view.get_annotations():
            frame = OCRFrame(annotation, fps)
            i = frame.frame_num or frame.range
            frames[i] = frame
    return frames


def paginate(frames_list):
    """Generate pages from a list of frames"""
    pages = [[]]
    n_frames_on_page = 0
    for frame_num, frame in frames_list:
        if n_frames_on_page >= 4 and not frame["repeat"]:
            pages.append([])
            n_frames_on_page = 0

        pages[-1].append((frame_num, frame))

        if not frame["repeat"]:
            n_frames_on_page += 1

    return {i: page for (i, page) in enumerate(pages)}

def render_ocr(vid_path, page_number):
    """Iterate through frames and display the contents/alignments."""
    # Path for storing temporary images generated by cv2
    cv2_vid = cv2.VideoCapture(vid_path)
    f = open(session["frames_pages"])
    frames_pages = json.load(f)
    page = frames_pages[str(page_number)]
    for frame_num, frame in page:
        # If index is range instead of frame...
        if frame.get("range"):
            frame_num = (int(frame["range"][0]) + int(frame["range"][1])) / 2
        cv2_vid.set(1, frame_num)
        _, frame_cap = cv2_vid.read()
        with tempfile.NamedTemporaryFile(
                prefix="/app/static/tmp/", suffix=".jpg", delete=False) as tf:
            cv2.imwrite(tf.name, frame_cap)
            # "id" is just the name of the temp image file
            frame["id"] = tf.name[12:]

    return render_template('ocr.html',
                           vid_path=vid_path,
                           page=page,
                           n_pages=len(frames_pages),
                           page_number=str(page_number))


def find_duplicates(frames_list):
    """Find duplicate frames"""
    prev_frame = None
    for frame_num, frame in frames_list:
        if is_duplicate_ocr_frame(frame, prev_frame):
            frame["repeat"] = True
        prev_frame = frame
    return frames_list


def is_duplicate_ocr_frame(frame, prev_frame):
    if prev_frame:
        # Check Boundingbox distances
        rounded_prev = round_boxes(prev_frame["boxes"])
        for box in round_boxes(frame["boxes"]):
            if box in rounded_prev and frame["secs"]-prev_frame["secs"] < 5:
                return True
    return False


def round_boxes(boxes):
    # To account for jittery bounding boxes in OCR annotations
    rounded_boxes = []
    for box in boxes:
        rounded_box = []
        for coord in box[2]:
            rounded_box.append(round(coord/10)*10)
        rounded_boxes.append(rounded_box)
    return rounded_boxes


def get_ocr_views(mmif):
    """Return OCR views, which have TextDocument, BoundingBox, and Alignment annotations"""
    views = []
    ocr_apps = ["east-textdetection", "tesseract", "chyron-text-recognition", "slatedetection", "barsdetection"]
    for view in mmif.views:
        if any([ocr_app in view.metadata.app for ocr_app in ocr_apps]):
            views.append(view)
    return views

def save_json(dict):
    # jsonified_pages = json.dumps(dict)
    with tempfile.NamedTemporaryFile(
        prefix="/app/static/tmp/", suffix=".json", delete=False) as tf:
        pages_json = open(tf.name, "w")
        json.dump(dict, pages_json)
        session["frames_pages"] = tf.name